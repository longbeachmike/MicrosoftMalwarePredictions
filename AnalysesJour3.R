Train <- as.data.frame( TrainPretraiterEch100000 )

colnames(Train) <- c('ProductName',
                     'EngineVersion',
                     'AppVersion',
                     'AvSigVersion',
                     'IsBeta',
                     'RtpStateBitfield',
                     'IsSxsPassiveMode',
                     'DefaultBrowsersIdentifier',
                     'AVProductStatesIdentifier',
                     'AVProductsInstalled',
                     'AVProductsEnabled',
                     'CountryIdentifier',
                     'OrganizationIdentifier',
                     'Platform',
                     'Processor',
                     'OsVer',
                     'OsBuild',
                     'OsSuite',
                     'OsPlatformSubRelease',
                     'OsBuildLab',
                     'SkuEdition',
                     'IsProtected',
                     'SmartScreen',
                     'FireWall',
                     'Census_MDC2FormFactor',
                     'Census_OEMNameIdentifier',
                     'Census_ProcessorCoreCount',
                     'Census_ProcessorModelIdentifier',
                     'Census_PrimaryDiskTotalCapacity',
                     'Census_systemVolumeTotalCapacity',
                     'Census_HasOpticalDiskDrive',
                     'Census_TotalPhysicalRAM',
                     'Census_InternalPrimaryDiagonalDisplaySizeInInches',
                     'Census_InternalPrimaryDisplayResolutionHorizontal',
                     'Census_InternalPrimaryDisplayResolutionVertical',
                     'Census_PowerPlatformRoleName',
                     'Census_InternalBatteryNumberOfCharges',
                     'Census_OSEdition',
                     'Census_OSInstallTypeName',
                     'Census_OSInstallLanguageIdentifier',
                     'Census_OSWUAutoUpdateOptionsName',
                     'Census_GenuineStateName',
                     'Census_ActivationChannel',
                     'Census_IsSecureBootEnabled',
                     'Census_IsVirtualDevice',
                     'Census_IsTouchEnabled',
                     'Wdft_IsGamer',
                     'Wdft_RegionIdentifier',
                     'HasDetections')


Train[,c(8)] <- as.double(gsub(",",".",Train[,c(8)]))                     
Train[,c(9)] <- as.double(gsub(",",".",Train[,c(9)]))                     
Train[,c(12)] <- as.double(gsub(",",".",Train[,c(12)]))                    
Train[,c(13)] <- as.double(gsub(",",".",Train[,c(13)]))                    
Train[,c(20)] <- as.double(gsub(",",".",Train[,c(20)]))                     
Train[,c(26)] <- as.double(gsub(",",".",Train[,c(26)]))                     
Train[,c(28)] <- as.double(gsub(",",".",Train[,c(28)]))
#Train <- Train[, -c(8, 9, 12, 13, 20, 26, 28 )]


# Encoding dans les composantes principales
#
#

library(factoextra)

VariablesCorreles <- Train[, c(8, 9, 12, 13, 20, 26, 28 )]

VariablesCorreles.pca <- princomp(VariablesCorreles, cor = T, scores = TRUE)

fviz_eig(VariablesCorreles.pca)

fviz_pca_var(VariablesCorreles.pca,
             col.var = "contrib", # Color by contributions to the PC
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE     # Avoid text overlapping
)

ind.sup.coord <- predict(VariablesCorreles.pca)

cor(VariablesCorreles$OsBuildLab, VariablesCorreles$Census_ProcessorModelIdentifier)

cor(VariablesCorreles$OsBuildLab, VariablesCorreles$CountryIdentifier)
Train <- Train[, -c(8, 9, 12, 13, 20, 26, 28 )]
#Train <- cbind(Train[, -c(8, 9, 12, 13, 20, 26, 28 )], ind.sup.coord[,c(1:3)])
summary(Train)

#
#
#

Train$Census_OSInstallLanguageIdentifier <- as.double(gsub(",",".",Train$Census_OSInstallLanguageIdentifier))                     

Train$Census_InternalBatteryNumberOfCharges <- as.double(gsub(",",".",Train$Census_InternalBatteryNumberOfCharges))
Train$AppVersion <-  as.character(Train$AppVersion)

Train$OsVer <- as.character(Train$OsVer)
Train$OsSuite <- as.character(Train$OsSuite)
Train$OsBuild <- as.character(Train$OsBuild )               
Train$AVProductsEnabled <- as.character(Train$AVProductsEnabled ) 
Train$RtpStateBitfield <-  as.character(Train$RtpStateBitfield)
Train$AVProductsInstalled <-  as.character(Train$AVProductsInstalled)
Train$Wdft_RegionIdentifier <-  as.character(Train$Wdft_RegionIdentifier)



summary(Train)
# Nouvelle variable 
Train$PixelsPerInches <- Train$Census_InternalPrimaryDisplayResolutionHorizontal * Train$Census_InternalPrimaryDisplayResolutionVertical / Train$Census_InternalPrimaryDiagonalDisplaySizeInInches 
Train <- subset(Train, select=-c( Census_InternalPrimaryDisplayResolutionHorizontal, Census_InternalPrimaryDisplayResolutionVertical,  Census_InternalPrimaryDiagonalDisplaySizeInInches))
Train$RamEtTotalCapacity <- log((Train$Census_TotalPhysicalRAM+1) / (Train$Census_systemVolumeTotalCapacity + 1))
# Enleve
Train <- subset(Train, select=-c(Census_TotalPhysicalRAM, Census_systemVolumeTotalCapacity))
Train <- subset(Train, select=-c(AvSigVersion, IsBeta))

summary(Train)
# Analyse en composante principale sur les variables numeriques.

is.logical2 <- function(x) {
  if(length(unique(x)) == 2 && !any(unique(x) > 1 || unique(x) < 0) ){
    return(T)
  }
  else return(F)
}
AttributsBinaires <- which(sapply(Train, is.logical2) == T) # 12
# On met en logique pour qu'il ne soit pas attrapes par les attributs numeriques
table(Train$AVProductsEnabled)
unique(Train$AVProductsEnabled) > c(0,1) || unique(Train$AVProductsEnabled) == 1
Train[,AttributsBinaires] <- lapply(Train[,AttributsBinaires], as.logical)

# Conversion des attributs numeriques en standardise 
AttributsNumeriques <- which(sapply(Train, is.numeric) == T)
AttributsNumeriques2 <- which(sapply(Train[, AttributsNumeriques], function(x) ifelse(max(x) <= 1 && min(x) >= 0,T,F) ) == F)

Train[,names(AttributsNumeriques2)] <- sapply(Train[,names(AttributsNumeriques2)], function(x) (x - median(x))/sd(x))

# Remet les attributs binaires en 0,1
Train[,AttributsBinaires] <- lapply(Train[,AttributsBinaires], as.numeric)

# Transforme les attributs facteurs en facteurs
AttributsFacteurs <- which(sapply(Train, is.character) == T)



### Elimination des variables facteurs contribuant a la non convergence 


table(Train$ProductName, Train$HasDetections) # ok
table(Train$EngineVersion, Train$HasDetections) # ok
table(Train$AppVersion, Train$HasDetections) # 4.4, 4.5, 4.6, 4.7 dans 4.1
Train$AppVersion <- ifelse(Train$AppVersion %in% c("4.4", "4.5", "4.6", "4.7"),"4.1",Train$AppVersion)
table(Train$RtpStateBitfield, Train$HasDetections) # 1, 3, 5, 8 dans 7
Train$RtpStateBitfield <- ifelse(Train$RtpStateBitfield %in% c("1", "3", "5", "8"),"7",Train$RtpStateBitfield)
table(Train$AVProductsInstalled, Train$HasDetections) # 5, 6 dans 1 
Train$AVProductsInstalled <- ifelse(Train$AVProductsInstalled %in% c("5", "6"),"1",Train$AVProductsInstalled)
table(Train$AVProductsEnabled, Train$HasDetections) # 4, 5 dand 1 
Train$AVProductsEnabled <- ifelse(Train$AVProductsEnabled %in% c("4", "5"),"1",Train$AVProductsEnabled)
table(Train$Platform, Train$HasDetections) # ok 
table(Train$Processor, Train$HasDetections) # arm64 dans x64
Train$Processor <- ifelse(Train$Processor %in% c("arm64"),"x64",Train$Processor)
table(Train$OsVer, Train$HasDetections) # ok
table(Train$OsBuild, Train$HasDetections) # 18 dans 17
Train$OsBuild <- ifelse(Train$OsBuild %in% c("18"),"17",Train$OsBuild)
table(Train$OsSuite, Train$HasDetections) #16, 30, 40, 78 dans 76
Train$OsSuite <- ifelse(Train$OsSuite %in% c("16", "30", "40", "78"),"76",Train$OsSuite)
table(Train$OsPlatformSubRelease, Train$HasDetections) # ok
table(Train$SkuEdition, Train$HasDetections) # ok
table(Train$SmartScreen, Train$HasDetections) # ADRESSE, ON dans INCONNUE
Train$SmartScreen <- ifelse(Train$SmartScreen %in% c("ADRESSE", "ON"),"INCONNUE",Train$SmartScreen)
table(Train$Census_MDC2FormFactor, Train$HasDetections) # Ok
table(Train$Census_PowerPlatformRoleName, Train$HasDetections) # ok
table(Train$Census_OSEdition, Train$HasDetections) # ok
table(Train$Census_OSInstallTypeName, Train$HasDetections) # ok
table(Train$Census_OSWUAutoUpdateOptionsName, Train$HasDetections) # ok
table(Train$Census_GenuineStateName, Train$HasDetections) # ok 
table(Train$Census_ActivationChannel, Train$HasDetections) # dans RETAIL:TB:E dans RETAIL
Train$Census_ActivationChannel <- ifelse(Train$Census_ActivationChannel %in% c("RETAIL:TB:E"),"RETAIL",Train$Census_ActivationChannel)
table(Train$Wdft_RegionIdentifier, Train$HasDetections) # ok



Train[,AttributsFacteurs] <- lapply(Train[,AttributsFacteurs], as.factor)

Train2 <- Train

summary(Train)



# Matrice de correlations
#source("http://www.sthda.com/upload/rquery_cormat.r")
#library(corrplot)
#rquery.cormat(yy)

#hist(sort(sapply(yy[,-c(127)], function(x) cor(x,yy$HasDetections))))

dim(Train)

summary(Train)

#### Transformations Dummys
TrainDummys <- model.matrix(  ~ ., data=Train2)
yy <- as.data.frame(TrainDummys)
yy <- yy[,-1]
dim(yy)
# ajustement du modèle avec les composantes principales.

fit <- glm( Train$HasDetections ~ .,data=yy, family = 'binomial')
summary(fit)
prob=predict(fit,type=c("response"))    

### Visualisation de la performance du modèle.
library(ROCR)    
pred <- prediction(prob, Train$HasDetections )    
perf <- performance(pred,  measure = "tpr", x.measure = "fpr")     
AireSousLaCourbeRoc <- performance(pred, "auc")     

plot(perf, col=rainbow(7), main="ROC curve ", xlab="Specificity", 
     ylab="Sensitivity")    
abline(0, 1) #add a 45 degree line


#### modele 2 : enleve les parametres non significatifs (si une modalite est significatif on garde sinon on drop) (meilleur)

Train3 = subset(Train2, select = -c(AppVersion, IsSxsPassiveMode, AVProductsEnabled, Platform, OsVer, OsBuild, SkuEdition, FireWall, Census_ProcessorCoreCount, Census_PowerPlatformRoleName, Census_InternalBatteryNumberOfCharges, Census_OSEdition, Census_IsSecureBootEnabled, PixelsPerInches) )


#### Transformations Dummys
TrainDummys <- model.matrix(  ~ ., data=Train3)
yy <- as.data.frame(TrainDummys)
yy <- yy[,-1]
dim(yy)
# ajustement du modèle avec les composantes principales.

fit <- glm( Train$HasDetections ~ .,data=yy, family = 'binomial')
summary(fit)
prob=predict(fit,type=c("response"))    

### Visualisation de la performance du modèle.
library(ROCR)    
pred <- prediction(prob, Train$HasDetections )    
perf <- performance(pred,  measure = "tpr", x.measure = "fpr")     
AireSousLaCourbeRoc <- performance(pred, "auc")     

plot(perf, col=rainbow(7), main="ROC curve ", xlab="Specificity", 
     ylab="Sensitivity")    
abline(0, 1) 



#### modele 3 : boosted model !


#### Transformations Dummys
TrainDummys <- model.matrix(  ~ ., data=Train3)
yy <- as.data.frame(TrainDummys)
yy <- yy[,-1]

library(gbm)
fit <- gbm(Train$HasDetections ~ ., distribution = "bernoulli", data=yy, cv.folds = 5)
summary(fit)
best.iter <- gbm.perf(fit, method = "cv")
print(best.iter)
prob=predict(fit,type=c("response"), n.trees = best.iter)    

### Visualisation de la performance du modèle.
library(ROCR)    
pred <- prediction(prob, Train$HasDetections )    
perf <- performance(pred,  measure = "tpr", x.measure = "fpr")     
AireSousLaCourbeRoc <- performance(pred, "auc")     

plot(perf, col=rainbow(7), main="ROC curve ", xlab="Specificity", 
     ylab="Sensitivity")    
abline(0, 1) 




#### modele 4 : Arbre de decision !


#### Transformations Dummys
TrainDummys <- model.matrix(  ~ ., data=Train2)
yy <- as.data.frame(TrainDummys)
yy <- yy[,-1]

library(rpart)

# grow tree 
fit <- rpart(Train2$HasDetections ~ ., method="class", data=Train2)
summary(fit)
#pfit<- prune(fit, cp=   fit$cptable[which.min(fit$cptable[,"xerror"]),"CP"])
#prob=predict(pfit, type=c('vector'))    
prob=predict(fit, type=c('vector')) 
plot(fit, uniform=TRUE, 
     main="Classification Tree")
text(fit, use.n=TRUE, all=TRUE, cex=.8)
### Visualisation de la performance du modèle.
library(ROCR)    
pred <- prediction(prob, Train2$HasDetections )    
perf <- performance(pred,  measure = "tpr", x.measure = "fpr")     
AireSousLaCourbeRoc <- performance(pred, "auc")     

plot(perf, col=rainbow(7), main="ROC curve ", xlab="Specificity", 
     ylab="Sensitivity")    
abline(0, 1) 
